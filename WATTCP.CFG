#
#  Waterloo TCP/IP sample configuration file.
#
#  Use this file as a template to make your own.
#  This file should be located in "current directory" or in a *directory*
#  pointed to by the environment variable "WATTCP.CFG".
#
#  This file is searched in the following directories until found:
#   1. via the environment variable "WATTCP.CFG".
#   2. in the current directory.
#   3. in the directory of the executing program (if DOS 3+ used).
#
#  E.g. Put a copy of this file in "c:\net\watt\bin" and insert this
#       line in your AUTOEXEC.BAT (or %SystemRoot%\SYSTEM32\AUTOEXEC.NT):
#
#         SET WATTCP.CFG=C:\NET\WATT\BIN
#
#  Note 1: No trailing `\' at end of line, and no spaces around the `='.
#
#  Note 2: The order of keywords/value pairs are significant.
#    For instance, if you have "134.121.10.8 my_dns" in your
#    "C:\NET\WATT\BIN\HOSTS" file, then "HOSTS = C:\NET\WATT\BIN\HOSTS"
#    *must* be listed before the line specifying your name-server;
#    "NAMESERVER = my_dns".  The same rule applies to "GATEWAY" and "COOKIE".
#
#  Note 3: the value (right of `=') is the default if you comment the
#    line out. Comments starts with `#' or `;'. To use `#' or `;' inside
#    string values, the string must be put in quotes.
#    E.g. these keywords have different values:
#      keyword1 = "hello world #;"
#      keyword2 = "hello world "#;
#
#  Note 4: The right-side value may contain an environment variable that
#    will be expanded when read. The effect is like in a Makefile.
#    E.g. if environment variable "ETC" is "C:\NET\WATT\BIN",
#         "$(ETC)\HOSTS" becomes "C:\NET\WATT\BIN\HOSTS" after
#         expansion.  See "README.TOO" for details.
#
#  Note 5: keyword and values are generally not case sensitive.
#
#  Note 6: Ethernet (MAC) addresses (i.e. <ether-address>) can be
#          specified on both colon (':') form or dash ('-') forms.
#          E.g. these should be equivalents:
#              00:00:C5:98:1D-10
#              00-00-C5-98-1D-10     (lower/uppercase hex doesn't matter)
#
#  Note 7: Remember that all this text takes time to parse (especially on
#    a 386 or older CPU). Cut down the contents of your "WATTCP.CFG" (not
#    this file, a copy) to a minimum to improve parsing speed.
#
#
# Text printed to screen (stdout).
#
print = "Waterloo TCP/IP setup"   ; optional key/value

#
# Packet-driver configuration for DOS targets. For Win32 and
# WinPcap/AirPcap/SwsVpkt configuration, see "winpkt." settings below.
#
# What packet-driver API vector to use.
# Most drivers use a value in range 0x60 - 0x80. Newer drivers complying
# to the 1.11+ specification allows the range to be 0x20 - 0xFF.
#
# Default behaviour (value 0x00) is to search for first packet-driver vector
# in range 0x60 - 0x80. If you have a new (1.11+) driver with a software
# API outside this range, you MUST specify that interrupt here.
#
pkt.vector = 0x00   ; optional

#
# Number of retries if PKTDRVR transmit fails.
# (total attempts are pkt.txretries+1).
# Printed in statistics output (print_mac_stats()) as "Tx retries".
#
pkt.txretries = 2   ; optional

#
# Number of milli-sec to wait between transmit retries.
# For the NDIS3PKT driver this is fixed at 1 milli-sec.
#
pkt.txwait = 0   ; optional

#
# Set the packet-driver receive mode. Normally not needed, but experience
# has shown that some drivers may have problem receiving traffic needed for
# e.g IPv6. Can also be handy for sniffing (pkt.rxmode = 6).
# Only effective if Watt-32 was compiled with USE_MULTICAST or USE_IPV6.
#
# Note: If you use the NDIS3PKT driver under Windows-XP and create a
#       bridging adapter (MAC Bridge Miniport), you may need to use
#       mode 6. I have no idea why.
#
# These modes are supported:
#
#   1 = Turn receiver off (take care!)
#   2 = Direct, receive only traffic to this PC
#   3 = mode 2 + broadcast (default for IPv4)
#   4 = mode 3 + limited multicast
#   5 = mode 3 + all multicast (default for IPv6)
#   6 = promiscuous mode, receive all traffic
#
pkt.rxmode = 3  ; optional

#
# Use near-pointers to access the PKTDRVR Rx/Tx buffers. Only effective
# for djgpp programs. DOS4GW style programs uses this by default.
# djgpp applications using Watt-32 MUST enable near-pointers before
# this setting takes effect. I.e something like this must be in your
# code; 'int _crt0_startup_flags = _CRT0_FLAG_NEARPTR;' Near-pointers
# are not possible under Windows. I.e. the above bit is silently ignored.
#
# NOTE: Enabling near-pointers disables page protection! Take care.
#
pkt.near_ptr = 0  ; optional (djgpp only)

#
# The number of receive buffers to allocate in low DOS-memory. Only
# effective for 32-bit targets. 16-bit programs use only 5 buffers.
# A value between 2 and 40 is accepted. If you spawn other Watt-32 or
# WatTcp programs and run out DOS-memory, reduce this value.
#
# NO EFFECT YET!
#
# NOTE: If Watt-32 was compiled without USE_FAST_PKT, there is no upper
#       limit (except RAM). The default library is compiled with
#       USE_FAST_PKT to avoid delays in real-mode callbacks.
#
pkt.rxbufs = 30   ; optional

#
# At program exit and before freeing the allocated receiver callback,
# try to reset the interface. From the 1.09 spec:
#   Resets the interface associated with handle to a known state,
#   aborting any transmits in process and reinitialising the receiver.
#   The local net address is reset to the default (from ROM), the
#   multicast list is cleared, and the receive mode is set to 3 (own
#   address & broadcasts). If multiple handles are open, these actions
#   might seriously disrupt other applications using the interface,
#   so CANT_RESET should be returned.
#
# This setting has no effect on some drivers (e.g. NDIS3PKT).
#
pkt.reset = 0  ; optional

#
# Configuration for Windows only; WinPcap, AirPcap or SwsVpkt drivers.
#
# Specify what WinPcap/AirPcap/SwsVpkt device to use. Default is to search
# for the first suitable device (one with an IPv4-address). To use a WinPcap
# device, specify one on the "\Device\NPF_{...}" form to override. To use
# a SwsVpkt device, use "\\.\SwsVpkt0" through "\\.\SwsVpkt31".

# Some ways to obtain the NPF (WinPcap) device name is to:
#   1) Run "windump -Dv" and it would hopefully list all supported devices.
#
#   2) Set the below "winpkt.dumpfile = $(TEMP)\winpkt_dump.txt" and run any
#      Watt-32 program at debug-level 2 or above. I.e. use "debug = 2" below.
#      Or run "tcpinfo -d". Look at the dumpfile for any hints (an adapter with
#      an IPv4-address is a good hint).
#
#   3) Or run this command:
#       netsh winsock show catalog | grep _tcpip_
#
#     this will show the Winsock low-level LSP providers. The utput is something
#     like:
#        ...  [\Device\NetBT_Tcpip_{75451EE7-5145-471A-BAF5-124BE8439D10}]   DATAGRAM 4
#     The GUID (string inside {..}) is the suffix for "\Device\NPF_".
#
# Note: none of the above "PKT." settings are used on Windows.
#       AirPcap is available from http://www.riverbed.com/us/products/cascade/wireshark_enhancements/airpcap.php
#       SwsVpkt is available from http://www.softsystem.co.uk/products/swsvpkt.htm
#       WinPcap is available from http://www.winpcap.org.
#
winpkt.device =  ; optional

#
# The trace-level for winpkt.c code.
#
winpkt.trace = 0 ; optional

#
# Same as "pkt.txretries" above.
#
winpkt.txretries = 2 ; optional

#
# The receive mode to use.
#
# A combination of these modes can be used. Not all combination may work,
# so take care:
#
#   0x01 = Direct            - Receive traffic destined for this adapter.
#   0x02 = Limited Multicast - Only traffic belonging to adapter's group.
#   0x04 = All Multicast     - All link-layer multicast traffic
#   0x08 = Broadcast         - All '1' destination MAC addresses.
#   0x20 = Promiscous mode   - Receive all traffic.
#   0x80 = All local         - Direct + broadcast + limited multicast +
#                              traffic generated by adapter (i.e. loops).
#
# Note: don't mix the values of "pkt.rxmode" with these bit values. They
#       are specified by NDIS. The "pkt.rxmode" values above are specified
#       by thwe PKTDRVR specification.
#
# The default mode is directed and broadcast traffic (0x09).
#
winpkt.rxmode = 0x09  ; optional

#
# Determines the size of kernel-level receive work buffer for the NPF driver.
# Also set the size of the user-level work buffer used (i.e. buffer for
# PacketReceivePacket() and ReadFile(). Ref. PacketSetBuff() in WinPcap docs.
# Tune this parameter for max performance.
# Size of each work buffer becomes "winpkt.rxbufs * 1540".
#
# Note: If you're running on a system with more than 1 CPU, the kernel-level
#       buffer gets divided between each CPU. Also note that WinPcap prior to
#       version 3.1 support only single-CPU systems.
#
# Note: This setting has no effect when using SwsVpkt.
#
winpkt.rxbufs = 20  ; optional

#
# Enable high-priority for the WinPcap/SwsVpkt capture thread.
# Should only be needed for low latency applications, like flood-ping :-)
#
winpkt.highprio = 0  ; optional

#
# Dump-file to print WinPcap/SwsVpkt debug information to.
# This file is only created at startup if debug level (debug_on) is >= 2.
# Use "debug = 2" above or call "tcp_setdebug_state(2)".
#
winpkt.dumpfile = $(TEMP)\winpcap_dump.txt  ; optional

#
# If using a fixed IP-address, insert the dotted decimal address below.
# If your LAN has a DHCP server, use "my_ip = dhcp".
# Likewise, if you want to get your IP-address via BOOTP or RARP servers.
#
my_ip = dhcp  ; mandatory

#
# The name of this host excluding the domain-name.
# Note: may be overridden by DHCP/BOOTP server.
#       Max 50 characters.
#
hostname = "random-pc" ; optional

#
# A better method would be to define it via the environment.
# Use $(COMPUTERNAME) if running under Windows for a consistent name here.
#
#hostname = $(COMPUTERNAME)

#
# The netmask specifying the sub-net you are on.
# Note: may be overridden by DHCP/BOOTP server.
#
netmask = 255.255.255.0  ; mandatory if not using DHCP

#
# IP-address (or name) of DNS host(s). The DNS host's job is to
# translate hostnames to IP-addresses if the hostname isn't listed
# in "$(ETC)\hosts".
#
# Notes: DHCP/BOOTP servers may add additional name-servers to the one(s)
#        you specify here.
#        There are no default server.  There can be a total of 10
#        nameservers. All name-server are queried in sequence (starting with
#        the first listed below) until an IP-address is returned. Enter the
#        fastest or closest name-server first for best result.
#        There are several public nameservers available. E.g. Google has
#        several. So you can use "nameserver = 8.8.8.8" or "8.8.4.4"
#
# nameserver = 0.0.0.0  ; primary DNS, mandatory if not using DHCP
# nameserver = 0.0.0.0  ; secondary DNS, optional

#
# The IP-address (or name) of your gateway(s).
# If you are running DOS-PPP with EtherNet emulation this should be
# replaced with $(REMIP). For SLIP or normal PPP, gateway is not used.
#
# The syntax is "ip-addr [,subnet [,mask]]"
#
# Notes: Will most likely be overridden by DHCP/BOOTP server.
#        The ARP-routing table is limited to 8 gateways.
#        The ARP-cache is limited to 64 entries.
#
# gateway = 0.0.0.0  ; mandatory if not using BOOTP/DHCP

#
# You can have maximum 8 "gateway" statements. E.g. if
# your default gateway is 10.0.0.1, but you need to use the gateway
# 10.0.0.2 to reach host 10.0.0.10, use this statement:
#   "gateway = 10.0.0.2, 10.0.0.10, 255.255.255.255"
#

# The Internet Domain Name of your network (of which your subnet is
# part of). The "Fully Qualified Domain Name" (FQDN) of your host is
# hostname + domain.suffix. E.g. "random-pc.your.domain.com".
#
# Note: "domain.suffix" (or previously named "domainslist", "domainlist")
#       is used by the DNS client to resolve "dot-less names" (i.e. no
#       `.' in host-name) recursively.
#       E.g. resolving "random-pc2" will query all DNS-servers for these
#            names until an IP-address is found:
#              "random-pc2.your.domain.com"
#              "random-pc2.domain.com"
#              "random-pc2.com"
#              "random-pc2"
#
#       This behaviour can be turned off with "domain.recurse = 0"
#       See below.
#
# Note: domain.suffix may be overridden by DHCP server.
#       Max 50 characters.
#
domain.suffix = your.domain.com  ; mandatory if not using DHCP

#
# The old name for "domain.suffix". It has the same effect, but don't
# use both versions.
#
# domainslist = your.domain.com  ; mandatory if not using DHCP

#
# The total time waiting for response (and including re-transmissions)
# from each DNS-host. The total host lookup time is <domain.timeout> *
# <number of nameservers>.  A value <4*sockdelay> is used if not defined
# (or if domain.timeout = 0).
#
domain.timeout = 0  ; optional

#
# Recursively resolve dot-less names. See above. If set to "0", only
# requests for "name" is sent to DNS-servers. Also known as "Domain-name
# devolution".
#
domain.recurse = 1  ; optional

#
# Enable lookup of names with non-ASCII characters via ACE and IDNA
# (Internationalizing Domain Names in Applications, RFC-3490).
# If set to 0, names are never converted to/from ACE format.
# Only effctive if built with USE_IDNA (ref. config.h).
#
domain.idna = 1  ; optional

#
# Try to resolve a name to an IPv6 address in programs that uses
# "gethostbyname2("host",AF_INET6)" or "getaddrinfo()". Default is to
# try resolve using an AAAA record before an A record. Set to 0 to
# skip trying to resolve to an IPv6-address.
#
domain.do_ipv6 = 1  ; optional

#
# Bit-values for Query/Write of the WinDns (dnsapi.dll):
#   0x0001 - Query cache before resolving a name to an IPv4 address   (A).
#   0x0002 - Query cache before resolving a name to an IPv6 address   (AAAAA).
#   0x0004 - Query cache before resolving an IPv4 addresses to a name (PTR).
#   0x0008 - Query cache before resolving an IPv6 addresses to a name (PTR).
#
#   0x0100 - Try to register a name + IPv4 address with the DNS service.
#   0x0200 - Try to register a name + IPv6 address with the DNS service.
#
# Registering is attempted after a local A/AAAA query succeeds.
# Currently effective only for native Windows programs.
# This setting only have effect for Win32 programs.
#
domain.windns = 0x0000  ; optional

#
# If using a PPP-driver your host-name will normally be different each
# time you get online. To query your true host-name set value below to 1.
# The penalty for using this option is a small delay since your assigned
# IP-address (MY_IP) must be reverse resolved into a Fully Qualified
# Domain Name (FQDN).
#
# Note: The use of this option will cause any HOSTNAME or DOMAIN.SUFFIX to
#       be over-written. Any host-name or domain-name coming from BOOTP or
#       DHPC will also be over-written.
#
dynamic_host = 0  ; optional

#
# Choose a random local port in range 1025 - 1500 for new connections.
# Used to bypass problems with fire-walls (real hardware fire-walls or
# software fire-walls). I.e. when a Watt-32 program ends prematurely, the
# firewall still have the connection in it's table. When the client
# restarts (before the 2*MSL), the firewall thinks it's the same
# connection continuing. Hence the initial SYN gets dropped.
#
rand_lport = 1  ; optional

#
# Connection timeout used by the BSD-socket API and connect() function
# (and for DNS-lookups).
# Default value is 30 sec.
#
sockdelay = 30  ; optional

#
# Inactivity timeout for TCP-sockets. A timer is started at reception
# of a TCP-segment and checked at each tcp_tick().
# Default value is 0 meaning no timeout.
#
inactive = 0  ; optional

#
# Data timeout for TCP-sockets. A timer is started when data is sent
# and checked at each tcp_tick(). The socket is closed if timed out.
# Default value is 0 meaning no timeout.
#
datatimeout = 0 ; optional

#
# Enable UDP/TCP-debug mode. Set to 1 (or higher for more details) to
# print information regarding the TCP state-machine or UDP errors etc.
# This applies to debug messages sent to screen only. For packet-traces
# to file, see "debug.file" below.  Default value is 0.
#
debug = 0  ; optional

#
# Maximum Segment Size. The maximum size of each TCP-segment you are
# willing to receive is specified here. The upper limit of MSS is 40
# bytes less than the MRU (Maximum Receive Unit) of the link-layer.
# 40 = size of IP+TCP headers.
# E.g. 1460 for EtherNet or the MRU-40 for a PPP-driver.
#
# MSS is only used for TCP-sockets. The size of received
# UDP-datagrams cannot be controlled, but is limited to 1472 (1500-28).
#
# Default value of MSS is 1460.
#
mss = 1460  ; optional

#
# Maximum Transmission Units. The maximum size of any packet sent
# to the link-layer. Note: This value may be overridden by value
# returned by PKTDRVR (if driver is an extended driver).
#
# Default (and upper-bound) value is 1500.
#
mtu = 1500  ; optional

#
# TCP Nagle algorithm. This is on by default.
# Disabling it here, disables it for *all* socket. You better
# use sock_mode() to control it per socket.
#
tcp.nagle = 1   ; optional

#
# Various RFC-1323 TCP options.
#
# Use "Time-Stamp" option on segments to better estimate round-trip
# time (RTT). Receive speed is around 10-20% better with this option
# on. But some old stacks don't like it, hence it's off by default.
#
tcp.opt.ts = 0  ; optional

#
# Selective Acknowledge option.
# Not implemented yet. Hence no effect.
#
tcp.opt.sack = 0  ; optional

#
# Window Scaling option can extend the receive window beyond 64 kBytes.
# Not implemented yet. Hence no effect.
#
tcp.opt.wscale = 0  ; optional

#
# Default receive window used for opening active connections.
# This value currently only has effect on BSD sockets. Should be
# a multiple of MSS for best performance.
#
# Note: If using NDIS3PKT this value is clamped to 5000 due to buffer
#       limitations in NDIS.
#
tcp.recv_win = 16384  ; optional

#
# Path MTU discovery on opening TCP connections (ref. RFC1323)
# Not implemented yet, hence no effect.
#
tcp.mtu_discovery = 0  ; optional

#
# Enable "Path MTU Black-hole detection" (ref. RFC1323)
# Not implemented yet, hence no effect.
#
tcp.blackhole_detect = 0  ; optional

#
# TCP Timers
#
tcp.timer.open_to   = 1000    ; TCP open timer value
tcp.timer.close_to  = 1000    ; TCP close timer value
tcp.timer.rto_add   = 100     ; added value in RTO calculation
tcp.timer.rto_base  = 10      ; base RTO value
tcp.timer.rto_scale = 64      ; scaling factor for delayed ACKs
tcp.timer.retran_to = 10      ; time for doing retransmits
tcp.timer.max_vjsa  = 80000   ; Max VJ standard average;   SRTT   (80s)
tcp.timer.max_vjsd  = 20000   ; Max VJ standard deviation; RTTVAR (20s)

#
# How often to send reset for TCP connections request to a closed port.
# If 0, always send a RST. Otherwise never often than specified here.
# This is mainly to defeat port-scanners.
#
tcp.timer.reset_to = 100

#
# Time from connection is idle (no data sent/received) to starting
# sending TCP keep-alive probes. Only used by BSD-sockets and if socket-
# option SO_KEEPALIVE is set on the socket.
#
tcp.timer.keepalive = 120  ; optional

#
# The interval between TCP keep-alive probes. I.e. time until the 2nd
# probe is sent provided the connection is still idle and no ACK is
# received on the 1st probe.
#
tcp.timer.keepintvl = 30

#
# How long to send keep alive probes. If no replying ACK is received in
# this period, the connection is considered dead (the host vanished).
#
tcp.timer.max_idle = 60

#
# Sending an "ICMP Mask Request" message after startup may help isolate
# problems caused by setting wrong netmask (see above).
# The ICMP message is sent as link-layer broadcast and destination IP
# 255.255.255.255.
# There must be a host on the subnet that can answer this ICMP request.
# A warning ("Conflicting net-mask from ICMP Addr Mask Reply") is printed
# if the 2 netmasks differ.  Refer RFC-950 for details.
#
icmp_mask_req = 0  ; optional

#
# IP-address (or name) of cookie server(s) used by the COOKIE program.
# Most WinNT servers have cookie jars (allthough dull quotes).
# No default.
#
# cookie = 0.0.0.0 ; optional

#
# "ETC" is an environment variable that should point to your Waterloo
# bin-directory.
#
# File specifying the language translations for all strings internal
# to Waterloo.  Only German (de), Norwegian (no) and Swedish (se)
# translations are included at the moment.  The WATLANG.TXT file is
# very incomplete at this moment, so the effective language is English (en).
#
#language = en,$(ETC)\watlang.txt

#
# File specifying the list of <host-names> to <IPv4-address> mappings.
# This file is queried before any DNS-requests are performed.
# Note: Windows users may use the `hosts' file of the system.
#       On Win95/98/ME use `hosts = $(WINDIR)\system\hosts'
#       On WinNT/2K/XP use `hosts = $(WINDIR)\system32\drivers\etc\hosts'
#
# Same note applies to the `services', `protocol' and `networks' files.
#
# There can be several hosts files; simply insert several "hosts = file"
# lines below this line.
#
#hosts = $(ETC)\hosts  ; optional

#
# File specifying the list of <service-name> to <protocol> mappings.
# This file is used by the <netdb.h> functions (getservbyname() etc).
#
#services = $(ETC)\services  ; optional

#
# File specifying the list of <IP-protocol-name> to <IP-protocol-numbers>
# mappings. This file is used by the <netdb.h> functions (getprotobyname()
# etc).
#
# Note: this file should NOT be named `protocols' to avoid problems under
#       Win95/98 and targets supporting long file-names (e.g. djgpp)
#
#protocols = $(ETC)\protocol  ; optional

#
# File specifying the list of <network-numers> to <domain-names>
# mappings. This file is used by the <netdb.h> functions (getnetbyname() etc).
#
#networks = $(ETC)\networks  ; optional

#
# File specifying the list of <ether-address> to <host-names> mappings.
# Similar function as "ETHIP" keyword below (static ARP cache) except that
# ethers-file uses hostnames or IP addresses. If using hostnames there
# should be a <ip-address> mapping defined in the "$(ETC)\hosts" file.
#
# Note: The "$(ETC)\ethers" file is only effective if library was compiled
#       with `USE_ETHERS' (ref. .\src\config.h).  File is read and parsed
#       after all other configurable options have been read.
#
#ethers = $(ETC)\ethers  ; optional

#
# Measure execution speed for certain Watt-32 functions. Only effective
# for 32-bit programs (djgpp, Watcom, DMC, High-C and Win32) running on
# a Pentium CPU (the RDTSC instruction is used).
#
profile.enable = 0  ; optional

#
# The file to write profiling information to.
#
profile.file = .\wattcp.pro  ; optional

#
# Memory debugging (NOT YET).
# The method used is either Fortify (requires building with USE_FORTIFY)
# or MSVC debug runtime (in MSVCRTD.DLL or LIBCMTD.LIB).
#
memdbg.enable   = 0                   ; optional
memdbg.failrate = 0                   ; optional
memdbg.dumpfile = $(TEMP)\wattcp.mem  ; optional
memdbg.stack_dump = 1                 ; optional, 1 = simple. 2 = detailed

#
# Watt-32 DHCP configuration
#
# DHCP server address (broadcast)
#
dhcp.server = 0.0.0.0

#
# Enable DHCP trace messages
#
dhcp.trace = 0

#
# broadcast flag for older DHCP daemons (or WinNT)
# Should force the servers to reply by broadcast.
# Note: Many DHCP server ignore this flag and always reply by
#       broadcast.
#
dhcp.bcast = 1

#
# timeout while waiting for DHCP offer

#
dhcp.timeout = 10

#
# Number of DHCP discover retries
#
dhcp.retries = 3

#
# Do an ARP-Request on our assigned IP. I.e. send an ARP request
# to check if the assigned IP-address is really vacant. Decline the
# assignment if someone replies to our ARP-request.
#
# Not to be confused with a `gratuitous ARP'. Watt-32 always do that
# after a DHCP assignment. And also if "ARP.GRATIOTOUS = 1" if not
# using DHCP assigned address.
#
dhcp.arpcheck = 0

#
# The file for storing transient configuration.
# Use NUL to disable storing configuration.
#
dhcp.config = $(TEMP)\W32DHCP.TMP

#
#
#
dhcp.req_list = 3,6,8,9,12,15,19,20,23,26,35,36,37,38

#
#
#
dhcp.userclass = value1,value2   ; see RFC-3004

#
#
#
dhcp.vendclass = "Watt-32"   ; RFC-2132, option 60

#
# Configuration of sent/received IPv4 headers.
#
# Default "Time To Live" field in outgoing headers.
# A value between 0 (keep traffic on local LAN) and 255 is accepted.
#
ip.def_ttl = 254  ; optional

#
# Default "Type Of Service" field in outgoing headers.
# A 8-bit hex value:
#   0x00 = Unspecified
#   0x02 = Minimum cost
#   0x04 = Reliability
#   0x08 = High throughput
#   0x10 = Low delay
#
# Note: Other bits are masked off before transmission.
#       If TOS on incoming packets is > 0, this TOS is used on all
#       outgoing packets also.
#
ip.def_tos = 0x00  ; optional

#
# default increment of IP identifiers for outgoing headers.
#
ip.id_incr = 1  ; optional

#
# Default fragment reassembly time (sec) for incoming headers.
#
ip.frag_reasm = 15  ; optional

#
# Sets "Don't fragment" bit in IP-header. Affects all outgoing headers.
#
ip.dont_frag = 0  ; optional

#
# IP loopback mode bits:
#   0x01 - Enable the internal loopback device (at 127.x.x.x).
#   0x10 - Send to Winsock loopback device (experimental, not working).
#
# These settings are only effective if Watt-32 compiled with USE_LOOPBACK.
#
ip.loopback = 0x01  ; optional

#
# IPv6 configuration
#
# The address of this machine. Default address (preferred link-local) is
# extracted from the MAC-address; FE80::201:80FF:FE + last 3 bytes of
# MAC-address. The address until a PKTDRVR is found, is the anycast
# address (all zeros).
#
ip6.my_ip = ::  ; optional

#
# File specifying the list of <host-names> to <IPv6-address> mappings.
# This file is queried before any DNS-host is queried.
#
# There can be several hosts files; simply insert several "ip6.hosts = file"
# lines below this line. The above "$(ETC)\hosts" file is not used for
# IPv6 addresses at this time.
#
ip6.hosts6 = $(ETC)\hosts6

#
# NOT FINISHED.
#
# An IPv4 Gateway address to route all IPv4 mapped addresses through.
# E.g. destinations with the "::FFFF" prefix. There can only be one
# 6-to-4 gateway. No default.
#
ip6.6to4_gateway = 0.0.0.0  ; optional

#
# NOT FINISHED.
#
# Address or name of Terodo tunneling 6-to-4 server.
# E.g. 203.254.33.13
#      teredo.ipv6.microsoft.com
#
ip6.teredo = 0.0.0.0  ; optional

#
# Default "Time To Live" field in outgoing headers.
# A value between 0 (keep traffic on local LAN) and 255 is accepted.
#
ip6.def_ttl = 254  ; optional

#
# Use the RDTSC instructions for high-resolution timer calculations.
# If 0, use the 8254 timer chip (default).
#
# NOT YET. Use environment variable "USE_RDTSC=1" instead.
#
use_rdtsc = 0   ; optional

#
# Protocol debugging stuff (not related to "debug" above).
#
# Activated by calling dbug_init() before calling sock_init()
# from application. Only effective if library was built with USE_DEBUG.
# See "README.TOO" for details.
#
# Name of debug file ("con", "stdout" or "stderr" for console, "nul" for
# NULL-device). Put on RAM-disk for best performance.
#
# djgpp 2.04+ compiled programs may use "/dev/zero" or "/dev/full"
# for test purposes.
#
debug.file = wattcp.dbg  ; optional

#
# Don't show packets not destined for us or not generated by us.
# A combination of these values can be specified:
#
#  ETH   -> discard link-layer packets (for EtherNet/TokenRing only) (1)
#  ARP   -> discard ARP packets        (for EtherNet/TokenRing only)
#  RARP  -> discard RARP packets       (for EtherNet/TokenRing only)
#  IP    -> discard IP packets         (for EtherNet/TokenRing/PPP/SLIP)
#  BCAST -> discard link-layer broadcast or IP-broadcast
#  MCAST -> discard link-layer multicast
#  LOOP  -> discard packets looped by NDIS3 (2)
#  ALL   -> discard everything not to/from us.
#  NONE  -> trace all packets received.
#
# Note (1): ETH is also used for Token-Ring meaning MAC header.
#
# Note (2): NDIS (and packet-drivers under Windows) will loop all generated
#           broadcast traffic in all receive-modes. In promiscuous mode
#           (PKT.RXMODE = 6) it will also loop all non-broadcast traffic
#           generated by the interface.  Thus packets sent by us will show
#           up approximately 50-200 milli-sec later.
#
debug.filter = all   ; optional

#
# Which protocols (headers and data) to debug.  A combination of
# these values can be specified:
#  ETH, LLC, ARP, RARP, IP, UDP, TCP, ICMP, IGMP, SCTP or ALL.
#
# Note: ETH is also used for Token-Ring meaning MAC header.
#
debug.proto = arp/rarp/ip/udp/tcp/icmp/igmp/sctp

#
# What part of a packet to dump;
#  HEADER -> dump only protocol headers. E.g. UDP-head without data part.
#  ALL    -> both header and ascii/binary data-dump.
#
debug.mode = all

#
# Dump ARP-cache and statistics counters to "debug.file" at program exit.
# I.e. PKTDRVR statistics and packets received/transmitted.
#
debug.stat = 1  ; optional

#
# Dump details of DNS request/response packets on UDP/TCP src/dest port 53.
#
debug.dns = 1  ; optional

#
# Write to file in line-buffered mode. I.e. flush file after 256 bytes
# written. Handy to see last printout before a crash. Not recommended for
# normal operation as it slows down file I/O. No effect if "debug.pcap"
# mode is enabled.
#
debug.linebuf = 0  ; optional

#
# Write the "debug.file" in pcap binary format. Handy for later analysis
# using tcpdump, tcptrace, WireShark, etc.
#
# Note: The above "debug.filter" , "debug.proto" or "debug.mode" is
#       *not* effective when using pcap; All traffic and all protocol
#       layers are written to file.
#
# Note: Naming the "debug.file" with a ".gz" extension will use gzip
#       compression while writing it. Only effective if Watt-32 was
#       build with `USE_GZIP_PCAP'.
#
debug.pcap = 0  ; optional

#
# Perform extra CRT-debug checks on init and exit.
# Only effective if built for MSVC debug-mode ('-MDd' or '-MTd' under Windows).
#
debug.crtdbg_check = 0 ; optional

##
## Socket-layer debugging stuff. Only used by BSD-socket API.
## Activated by calling dbug_init() before calling sock_init()
## from application.
##
#
# where to print socket-debug;
#   <file>, "con", "stdout", "stderr" or "nul". On Windows a debug-
#   window can be specified with "$ODS" (OutputDebugString).
#
# As with "debug.file", put on RAM-disk for best performance.
#
sk_debug.device = wattcp.sk    ; in current directory

#
# C-style open mode for the "sk_debug.device".
#  "w+" write (and create if not exists)
#  "a"  append to file
#  "t"  "sk_debug.device" is a text-file.
#  "c"  commit file to disk (not supported by all compilers).
#
sk_debug.openmode = "w+"  ; default



#########################################################################
#########                                                       #########
#########  EVERYTHING BELOW THIS LINE IS FOR ADVANCED USE ONLY  #########
#########                                                       #########
#########################################################################

#
# multihomes     = 0                          ; uses MY_IP - (MY_IP+n)
# ethip          = <ether-addr1>, <ip4-addr1> ; static ARP-table
# ethip          = <ether-addr2>, <ip4-addr2> ;
# ethip          = <ether-addr3>, <ip4-addr3> ;
# eaddr          = <ether-addr>               ; sets my ether-address
# bootp          = 255.255.255.255            ; BOOTP host address
# bootp_to       = 30                         ; BOOTP timeout

# redirects      = tcp,udp,icmp,igmp   ; honour ICMP redirects (0 disables)
# netdb_alive    = 900                 ; cache-timeout for resolve   (def 15 min)

# arp.retrans_to = 250                 ; ARP retransmission interval (def 250 msec)
# arp.timeout    = 2                   ; ARP resolver timeout        (def 2 sec)
# arp.alive      = 300                 ; ARP life for cached entries (def 5 min)
# arp.num_cache  = 64                  ; max # of entries in ARP cache (not yet)
# arp.dead_gw_detect = 0               ; Gateway "black-hole" detection (not yet)
# arp.gratiotous     = 0               ; Send a gratiotous ARP on startup
# arp.trace          = 0               ; Trace AARP code (for debugging)

# include = ?$(ETC)\sarp.cfg           ; Secure ARP configuration (experimental)
# include = ?$(ETC)\ppp.cfg            ; PPP configuration
# include = ?$(ETC)\pppoe.cfg          ; PPPoE configuration
# include = ?$(ETC)\slip.cfg           ; SLIP configuration
# include = ?$(ETC)\rpc.cfg            ; RPC configuration
# include = ?$(ETC)\smb.cfg            ; SMB/RFC-NetBios configuration
# include = ?$(ETC)\dynip.cfg          ; dyndns.org client

#
# Service-order for DNS name lookups. Use `hosts' first. If name not
# in `hosts' file send a DNS request to nameserver(s).
# NOT YET IMPLEMENTED; order is always "hosts,bind".
# For IPv6, order is always "hosts6, bind6, hosts, bind".
#
# host.conf = order hosts, bind

#
# Configuration of bind resolver. These settings are active only if
# library was compiled with USE_BIND (ref. .\src\config.h) and using
# any of the resolver functions in <resolv.h>.
#
# HOSTALIASES points to a file which lists host aliases, e.g:
#  alfie.somewhere.net www.somewhere.net
#  blondie.foo.net     mail.mci.net
#
# Default value is taken from environment variable "HOSTALIASES".
#
bind.hostaliases = $(HOSTALIASES)  ; optional

#
# Options used for initialising the resolver. The value(s) are:
#   ndots:n  -> n specifies # of dots '.' in a domain (default 1).
#   debug    -> enable resolver debug mode.
#
# E.g. "bind.res_options = ndots:4 debug".
# See also the manpage for "bind".
#
# Default value is taken from environment variable "RES_OPTIONS".
#
bind.res_options = $(RES_OPTIONS)  ; optional

#
# Allow the following hosts to connect to our TCP listening sockets.
# Use comma-separated list for single hosts or regexp for multiple hosts.
# Ranges can be specified using "network/mask" notation. E.g.
#   "tcpd.hosts.allow = 133.212/16" will allow the hosts in range
# 133.212.0.0 - 133.212.255.255.
# NOT YET IMPLEMENTED; all hosts are allowed.
#
# tcpd.hosts.allow = *

#
# Deny the following hosts to connect to our TCP listening sockets.
# Use comma-separated list for single hosts or regexp for multiple hosts.
# Ranges can be specified using "network/mask" notation. See above.
# NOT YET IMPLEMENTED; only the broadcast and null-addresses are denied.
#
# tcpd.hosts.deny = 255.255.255.255, 0.0.0.0

#
# Simple syslog client configuration. Sends log messages to file and/or
# a logging host. Protocol used is UDP (unicast or broadcast).
# Only effective if application calls openlog() first.
#
# Messages are appended to file. Default filename is extracted from
# path and name of running application.
#
syslog.file = ; optional

#
# Which host to send logging messages to. If not specified here, it may
# be received via BOOTP or DHCP (if specified by "my_ip = bootp/dhcp", or
# "wattcp.cfg file is not found). The host MUST be a name listed in
# "$(ETC)\hosts" or a dotted IP-address. You can also specify a broadcast
# IP-address and hope the messages are picked up by a logging daemon.
#
syslog.host = ; optional

#
# Which UDP destination port to send to. Default is 514.
# The port is first searched in "$(ETC)\services". The line should be
# "syslog 514/udp". If not found there, the following port is used.
# i.e. the following line is overruled by "syslog port/udp" in
#     "$(ETC)\services".
#
syslog.port = 514  ; optional

#
# Syslog messages to be written to file and/or sent to logging host:
#
# A combination of the following may be specified (<sys/syslog.h> flags):
#  emerg   => system is unusable                  (LOG_EMERG)
#  alert   => action must be taken immediately    (LOG_ALERT)
#  crit    => critical conditions                 (LOG_CRIT)
#  error   => error conditions                    (LOG_ERR)
#  warning => warning conditions                  (LOG_WARNING)
#  notice  => normal but significant condition    (LOG_NOTICE)
#  info    => informational                       (LOG_INFO)
#  debug   => debug-level messages                (LOG_DEBUG)
#  all     => all combinations of above.
#
# Default level is "emerg/alert/error"
#
syslog.level = emerg/alert/error  ; optional

#
# TFTP client configuration.
#
# To actually enable loading of `tftp.boot_file' via TFTP protocol,
# the application must supply a "writer" hook through function pointer
# `tftp_writer'. See <tcp.h> or .\src\tftp.c.
#
# The TFTP client uses UDP on port 69 (unless specified differently in
# $(ETC)\services).
#
# Note: When using DHCP (TFTP options and BOOTP not supported), the
#       "tftp.boot_file" and "tftp.server" specified below *may* be
#       overridden by the DHCP-server. This is because a properly
#       configured DHCP-server should know what's best for you...
#
# Specify what file to load. This file may be present in an option
# coming from DHCP-server, but can be specified here.
#
# Note: remote file-name is server's file-name (relative to it's virtual
#       root) and may contain a path. It's the responsibility of the
#       application to map server's boot filename into your local file
#       system or create any missing directories.
#
# The format of "tftp.boot_file" is "remote name" optionally followed by a
# local name. E.g. "tftp.boot_file = /tftpd/bootp.file $(TEMP)\bootp.fil"
#
# Note: The remote/local filenames cannot contain any spaces or tabs.
#
tftp.boot_file = ; optional

#
# Specify what server (dotted ip-address or host from `hosts' file) to
# get TFTP.BOOT_FILE from. If not specified here, TFTP-server name MUST
# be given by DHCP server.
#
tftp.server = ; optional

#
# Specify timeout (in seconds) waiting for each packet from TFTP-server.
#
tftp.timeout = 8 ; optional

#
# Specify retry count waiting for packets from TFTP-server.
#
tftp.retry = 5 ; optional

#
# C-style open mode for the local file "tftp.boot_file".
# Specify "wt" to transfer a text file from a Unix-based TFTP server.
#
tftp.openmode = "wb"  ; default

#
# Specify transfer mode for retrieval. Either use "octet" (default) for
# 8-bit raw data, "netascii" or "mail". Ref. RFC-1350.
#
# Note: Some tftp servers (e.g. PumpKIN) ignores this mode.
#
tftp.mode = "octet" ; optional

#
# Specify local port to use. Default behaviour (0) is to select a random
# local port in range 1024 - 65535. If e.g. a firewall makes this
# difficult, use a fixed port above 1024.
#
tftp.port = 0 ; optional

#
# ECHO/DISCARD daemons
#
echo.daemon    = 0                 ; active echo service
echo.host      = 255.255.255.255   ; accept from anybody
echo.port      = 7                 ; listen on port 7

discard.daemon = 0                 ; active discard service
discard.host   = 255.255.255.255   ; accept from anybody
discard.port   = 9                 ; listen on port 9


#######################################################################
########                                                       ########
########   CONFIGURATION FOR VARIOUS WatTCP/Watt-32 PROGRAMS   ########
########                                                       ########
#######################################################################
#
# For details regarding these settings refer the documentation
# of respective programs.
#
# HTget by Ken Yap (ken@syd.dit.csiro.au)
#
http.proxy = <your.http.proxy>:<port>  ; no default

#
# Michael Ringe's TALK client/server
#
talk.localuser  = <your signature/handle>
talk.screenmode = autocr,split
talk.colors     = 1E,1A,71,71,71
talk.alias      = joe:joe@some.domain.com
talk.logfile    = $(WATTCP.CFG)\talk\talk.log
talk.message    = "%s is busy. Try again later.\n"

#
# SNUZ nntp client by
# Doug McDonald (mcdonald@aries.scs.uiuc.edu)
#
snuz.tmpdir = $(TEMP)
snuz.rc     = $(ETC)\news\snuz.rc      ; list of subscribed groups, etc
snuz.active = $(ETC)\news\active       ; list of all groups
snuz.host   = news.server.com          ; news server ipaddr
snuz.from   = joe@some.domain.com      ; the user's email-address
snuz.editor = edit.exe                 ; editor for writing posts
snuz.smtp   = "popmail send %H %D %f"  ; external sendmail program

#
# SMB Printer daemon 0.94 by
# Ken Yap (ken@syd.dit.csiro.au)
#
smbpd.workgroup    = "my-work-group"
smbpd.printer1name = "my-printer-at-lpt1"
smbpd.printer2name = "my-printer-at-lpt2"
smbpd.printer3name = "my-printer-at-lpt3"

#
# Erick Engelke's SMTP-server
#
smtp.subdir   = $(ETC)\smtpd\mail\  ; sub-dir for mail/temp files, must exist
smtp.sessions = 8                   ; # of SMTP sessions

#
# UCD-SNMP library
#
snmp.mibfile  = $(snmp)\mib.txt
snmp.mib2file = $(snmp)\mib-v2.txt


